해야할 일
- 전리품, 상점 등 스테이지 개발
- 스킬 인벤토리 개발
- 장신구 시스템 개발
- 걸작 시스템 개발
- 멀티 타겟팅 문제 해결

2025.05.01
플레이어 전투 매커니즘 개편
- 기존 공격 매커니즘 : json파일로 스킬 제작 -> Unity
- 

2025.05.05
- Ally, Enemy 행동 매커니즘 개발

2025.05.19
- Ally, Enemy 스킬 매커니즘 개발 완료
- Player 스킬 매커니즘 개발 완료
- 멀티 타겟팅에 문제 발생


보통 동료는 플레이어에 의한 소환수 혹은 퀘스트에 따른 도우미일 것임.
이때, 동료를 지켜야하는 수호 퀘스트는 동료한테 '도발' 상태이상을 걸면 되는 일.
소환수는 기본적으로 1기일 것인데, 적이 굳이 소환수를 타겟팅할 일은 필요없지 않을까싶음.
애초에 소환수라는 유닛들은 일반적으로 플레이어가 재소환이 가능할 것이기 때문.
즉, 일회성 혹은 시한부에 가까운 존재다.
따라서, 적이 소환수에게 스킬을 사용해 낭비되는 것보다 플레이어에게 집중 타격하는 것이 효율적이고 패턴 구축이 쉬움.
적은 범위공격이가 따로 존재하므로 해당 스킬로 소환수를 동시에 노리는 것을 염두해두면 좋을듯함.

Status_Effects.json => 상태이상별 스탯 정의
StatusEffect.cs => 상태이상의 스탯 자료형 결정, 해당 상태이상 추가/제거 함수 존재
EffectManager => 유닛마다 Status_Effects.json 파일을 로드할 수 있도록 하는 장치(함수)
유닛별.cs => 유닛별 AddStatusEffect()로 특정 상태이상을 부여 가능.
            TakeTurn() 함수 내에서 ApplyEffect()로 상태이상의 효과 적용
            및 RemoveEffect()로 상태이상 제거 가능
            
            유닛별로 ActiveStatusEffect[]에 상태이상 정보를 저장해서 사용하게 되는데,
            각 상태이상 정보를 수정(중첩 수 같은 정보)할 수 있다.

아군&적군의 스킬 구현 방법
1. 객체지향 : 유닛별 스크립트 내에서 제작 => 다양한 스킬 제작 가능(다양성Up) / 수정의 번거로움, 직관적이지 못함
2. ScriptableObject : ScriptableObject를 이용하여 제작 후 유닛마다 해당 Data를 끼워주는 식 => 수정의 간편함, 직관적, 보관 효율성Up / 지나치게 ScriptableObject가 늘어날 수 있음.
    Ex/ 한 챕터당 몬스터가 8마리일 시, 총 8챕터 = 몬스터 64종, 몬스터 64종 = 스킬 192종
3. ScriptableObject + 객체지향 : ScriptableObject로 제작 후 유닛별 Script로 최종 공격력 연산 혹은 기믹 추가 등으로 변형 가능

=> ScriptableObject의 수를 최소화시켜야 함.
=> 중복계열의 몬스터들이 존재 시 동일한 SkillData를 사용하면 된다. (이펙트나 스프라이트는 내부 Script로 구분하면 된다.)
=> 같은 계통의 몬스터 중에서도 하위종과 상위종이 구분되므로 스킬 데미지에 차이가 있어야한다. 혹은 부가 효과가 부여되어야한다.
=> 스킬 데미지는 ...

결론 : ScriptableObject로 아군/적의 스킬을 만든다. 다만 세부 조정의 가능성을 위해서 (같은 종류의 유닛별 돌려쓰기) 스킬 데미지와 버프 수치같은 세부 수치는 조절 가능하도록 만든다.


// 단타 공격
            case UnitSkillData.SkillType.SingleAtk:
                for (int i = 0; i < curSkillData.count; i++)   // 타수만큼 반복
                {
                    if (curSkillData.damage > 0)
                    {                        // 기본 데미지가 0일 시 스킵
                        damage = curSkillData.damage + target.HasBurnDebuff();     // 최종 데미지 = 기본 데미지 + 적 화상 수치
                        target.TakeDamage(damage);      // 공격
                    }

                    // 적 상태이상 부여
                    if (curSkillData.effect > 0)
                    {
                        target.AddStatusEffect(GameManager.instance.statusEffects.Find(s => s.name == curSkillData.effectType), curSkillData.effect);
                    }

                    Debug.Log($"{target}은 {damage} 의 데미지를 입었다.");
                }
                break;

            // 전체 공격
            case UnitSkillData.SkillType.SplashAtk:
                for (int a = 0; a < curSkillData.count; a++)   // 타수만큼 반복
                {
                    List<ITurn> allies = GameManager.instance.turnManager.allies;
                    for (int i = 0; i < allies.Count; i++)
                    {
                        if (curSkillData.damage > 0)
                        {                                        // 기본 데미지가 0일 시 스킵
                            damage = curSkillData.damage + allies[i].HasBurnDebuff();               // 최종 데미지 = 기본 데미지 + 적 화상 수치
                            allies[i].TakeDamage(damage);
                        }

                        // 적 디버프
                        if (curSkillData.effect > 0)
                        {
                            allies[i].AddStatusEffect(GameManager.instance.statusEffects.Find(s => s.name == curSkillData.effectType), curSkillData.effect);
                        }

                        Debug.Log($"{allies[i]}은 {damage} 의 데미지를 입었다.");
                    }
                }
                break;
            // 자신 보조
            case UnitSkillData.SkillType.SingleSup:    // 자기자신 타겟 스킬
                for (int i = 0; i < curSkillData.count; i++)   // 타수만큼 반복
                {
                    if (curSkillData.damage > 0)
                    {                        // 기본 데미지가 0일 시 스킵
                        damage = curSkillData.damage;     // 최종 데미지 = 기본 데미지 (자해 공격은 버프/디버프 영향X)
                        TakeDamage(damage);      // 자신 공격
                    }

                    // 플레이어 상태이상 부여
                    if (curSkillData.effect > 0)
                    {
                        AddStatusEffect(GameManager.instance.statusEffects.Find(s => s.name == curSkillData.effectType), curSkillData.effect);
                    }

                    Debug.Log($"{gameObject.name}은(는) {curSkillData.effectType} 버프를 획득했다.");
                }
                break;

            // 전체 아군 보조
            case UnitSkillData.SkillType.SplashSup:
                for (int a = 0; a < curSkillData.count; a++)   // 타수만큼 반복
                {    // 타수만큼 반복
                    List<ITurn> enemies = GameManager.instance.turnManager.enemies;
                    for (int i = 0; i < enemies.Count; i++)
                    {
                        if (curSkillData.damage > 0)
                        {                                        // 기본 데미지가 0일 시 스킵
                            damage = curSkillData.damage;               // 최종 데미지 = 기본 데미지 (자해 공격은 버프/디버프 영향X)
                            enemies[i].TakeDamage(damage);
                        }

                        // 아군 버프/디버프
                        if (curSkillData.effect > 0)
                        {
                            enemies[i].AddStatusEffect(GameManager.instance.statusEffects.Find(s => s.name == curSkillData.effectType), curSkillData.effect);
                        }

                        Debug.Log($"{enemies[i]}은(는) {curSkillData.effectType} 버프를 획득했다.");
                    }
                }
                break;

데미지가 안들어감!